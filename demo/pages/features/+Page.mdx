import { Link, FileRemoved, FileAdded, CodeBlockTransformer, Contribution } from '@brillout/docpress'

This page is for testing/developing DocPress features.

## Detached pages

- <Link href="/orphan" />
- <Link href="/orphan-2" />

## `<Link>`

- <Link href="/some-page" /> (basic link)
- <Link href="/orphan" /> (link to detached page)
- <Link href="#link" /> (same-page link, non-inferred original heading title without needing `sectionTitles`)
- <Link href="/notes#danger" /> (page link with hash)
- <Link href="#basic" /> (same-page link, sub heading)
- <Link href="#custom-hash" /> (custom hash)

### Custom URL hash for section heading{#custom-hash}

Custom URL hash:

```mdx
### Custom URL hash for section heading{#custom-hash}
```

> DocPress doesn't yet support `<h2 id="url-hash">${sectionTitle}</h2>` (it's a consideration to support it).


## Code blocks

### Basic

```js
console.log('hello')
console.log(`wo${'r'}ld`)
```

```
No language
Second line
```

### Diff

Powered by `shiki` and `rehype-pretty-code`.

Code diffs powered by `import { transformerNotationDiff } from '@shikijs/transformers'` and custom CSS rule at `css/code/diff.css`.

```ts
// /pages/+config.ts

import type { Config } from 'vike/types'

export default {
  meta: {
    Page: {
      // some comment https://github.com/brillout/docpress#readme
       env: { server: true, client: true }, // [!code --]
       env: { server: true } // [!code ++]
    }
  }
} satisfies Config
```

Removed/Added file using `<FileRemoved>`/`<FileAdded>` wrapper:

<FileRemoved>
```js
// old.js
export default /* ... */
```
</FileRemoved>

<FileAdded>
```js
// new.js

export default /* ... */
```
</FileAdded>

Old school diffs:

```diff
  no change
- deleted
  no change
+ added
  no change
```

### `<CodeBlockTransformer>`

`<CodeBlockTransformer lineBreak="white-space">`

<CodeBlockTransformer lineBreak="white-space">
```
Error [ERR_MODULE_NOT_FOUND]: Cannot find module 'node_modules/some-library/dist/esm/some-file' imported from node_modules/some-library/dist/esm/index.js
Did you mean to import some-file.js?
```
</CodeBlockTransformer>

`<CodeBlockTransformer lineBreak="break-word">`

<CodeBlockTransformer lineBreak="break-word">
```
Error [ERR_MODULE_NOT_FOUND]: Cannot find module 'node_modules/some-library/dist/esm/some-file' imported from node_modules/some-library/dist/esm/index.js
Did you mean to import some-file.js?
```
</CodeBlockTransformer>


## JavaScript toggle


```ts
const hello: string = 'world'
```

Note how `.ts` is replaced with `.js`:

```ts
// some-file-name.ts

const foo: { bar: number } = { bar: 42 } // someOtherFile.ts
// DocPress just uses a replaceAll() call: .ts
```

> Also works:
> - In blockquotes
> - In bullet points
>   ```ts
>   // Some TypeScript comment
>   type SomeMessage = {
>     msg: string
>   }
>   // Some comment
>   const someMessage: SomeMessage = {
>     msg: 'world'
>   }
>   ```

Using `ts-only`:
```ts ts-only
// some-file-name.ts

type Hello = {
  msg: string
}
const hello: Hello = {
  msg: 'world'
}
```

Using `yaml` (misusing the `yaml` language to list the filesystem):

```yaml
pages/+config.ts
pages/(marketing)/+config.ts
pages/(marketing)/index/+Page.ts # landing page
```

Using custom magic comments to ignore incorrect syntax, usually when displaying code diffs:

- Using `// @detype-replace dummyVarName varName` above the affected line.
- Using `// @detype-uncomment ` at the beginning of the affected line.

```ts
const hello: string = 'world' // [!code --]
// @detype-replace dummyhello hello
const dummyhello: string[] = ['hello', 'world'] // [!code ++]

// @detype-uncomment function greeting() { // [!code --]
function greeting(name: string) { // [!code ++]
  // ...
}
```

JS toggle is only shown if code changes (note how `file.ts` => `file.js` isn't a reason enough to show the toggle)

```ts
// file.ts
console.log(42)
```

Using `hide-menu` to hide the copy button, e.g.:

- Bash output:
  ```bash hide-menu
  > vike dev

    Vike v0.4.234  ready in 526 ms
    ➜  Local:   http://localhost:3000/
    ➜  Network: use --host to expose
    ➜  press h + enter to show help
  ```

- TypeScript typings with `ts-only` meta:
  ```ts ts-only hide-menu
  type Value = Record<string, string>
  type BodyAttributes = Value | ((pageContext) => Value)
  ```

Using `max-width`:

```ts max-width=50
async function onNewTodo(text: string) {
  await sql(
    'INSERT INTO todo_items VALUES (:text, :authorId)',
    { text, authorId: user.id }
  )
}
```


## Links in code blocks

```ts
// https://vike.dev
const a: number = 1
```

## CodeGroup

Using `choice=choice-name` meta to group code blocks into multiple choices:

```shell choice=hono
npm i hono @photonjs/hono
```

```shell choice=express
npm i express @photonjs/express
```

```ts choice=hono file-added
// server/index.ts

import { Hono } from 'hono'
import { apply, serve } from 'vike-photon/hono'

function startServer() {
  const app = new Hono()
  apply(app)
  return serve(app)
}

export default startServer()
```

```ts choice=express file-added
// server/index.ts

import express from 'express'
import { apply, serve } from 'vike-photon/express'

function startServer() {
  const app = express()
  apply(app)
  return serve(app)
}

export default startServer()
```

Using `:::Choice{#choice-name} {:mdx}` directive to combine multiple contents for a single choice:

:::Choice{#vike-react}
```tsx
import { ClientOnly } from 'vike-react/ClientOnly'

function Page() {
  return (
    <ClientOnly fallback={<p>Loading...</p>}>
      <SomeComponent />
    </ClientOnly>
  )
}
```

Props:
- **children**: Content rendered only on the client-side after hydration.
- **fallback** (optional): Content shown during SSR and before hydration completes.
:::

:::Choice{#vike-vue}
```vue
<template>
  <ClientOnly>
    <SomeComponent />
    <template #fallback>
      <p>Loading...</p>
    </template>
  </ClientOnly>
</template>

<script setup lang="ts">
import { ClientOnly } from 'vike-vue/ClientOnly'
</script>
```

Props:
- **default slot**: Content rendered only on the client-side after hydration.
- **fallback slot** (optional): Content shown during SSR and before hydration completes.
:::

:::Choice{#vike-solid}
```tsx
import { ClientOnly } from 'vike-solid/ClientOnly'

function Page() {
  return (
    <ClientOnly fallback={<p>Loading...</p>}>
      <SomeComponent />
    </ClientOnly>
  )
}
```

Props:
- **children**: Content rendered only on the client-side after hydration.
- **fallback** (optional): Content shown during SSR and before hydration completes.
:::